<table width="227">
<tbody>
<tr>
<td>
<p>JALADI VENKATA SAI SRIKAR</p>
<p>RA1811029010054</p>
<p>CSE-CN</p>
</td>
</tr>
</tbody>
</table>
<p><a title="DAA" href="https://srikardaa_website.com">https://srikardaa_website.com</a></p>
<h1>DESIGN AND ANALYSIS OF ALGORITHM</h1>
<p>In&nbsp;<a title="Computer science" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, the&nbsp;<strong>analysis of algorithms</strong>&nbsp;is the process of finding the&nbsp;<a title="Computational complexity" href="https://en.wikipedia.org/wiki/Computational_complexity">computational complexity</a>&nbsp;of algorithms &ndash; the amount of time, storage, or other resources needed to&nbsp;<a title="Computation" href="https://en.wikipedia.org/wiki/Computation">execute them</a>. Usually, this involves determining a&nbsp;<a title="Function (mathematics)" href="https://en.wikipedia.org/wiki/Function_(mathematics)">function</a>&nbsp;that relates the length of an algorithm's input to the number of steps it takes (its&nbsp;<a title="Time complexity" href="https://en.wikipedia.org/wiki/Time_complexity">time complexity</a>) or the number of storage locations it uses (its&nbsp;<a title="Space complexity" href="https://en.wikipedia.org/wiki/Space_complexity">space complexity</a>). An algorithm is said to be efficient when this function's values are small, or grow slowly compared to a growth in the size of the input. Different inputs of the same length may cause the algorithm to have different behavior, so&nbsp;<a title="Best, worst and average case" href="https://en.wikipedia.org/wiki/Best,_worst_and_average_case">best, worst and average case</a>&nbsp;descriptions might all be of practical interest. When not otherwise specified, the function describing the performance of an algorithm is usually an&nbsp;<a class="mw-redirect" title="Upper bound" href="https://en.wikipedia.org/wiki/Upper_bound">upper bound</a>, determined from the worst case inputs to the algorithm.</p>
<p>&nbsp;Here in this algorithms has 6 different paradigms</p>
<ul>
<li>BRUTE FORCE</li>
<li>DIVIDE AND CONQUER</li>
<li>GREETY ALGORITHM</li>
<li>DYNAMIC PROGRAMMING</li>
<li>BACKTRACKING</li>
<li>BRANCH AND BOUND</li>
</ul>
<p>DIVIDE AND CONQUER:</p>
<p>&nbsp;Here in divide and conquer we divide and and then find the solutions of the divided problems and then combine to form the single solution</p>
<p>algorithm for divide and conquer</p>
<p>DAC(Problem)</p>
<p>{</p>
<p>if(small(problem))</p>
<p>{</p>
<p>solve(problem);</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>divide problem into p1,p2,p3,...,pn</p>
<p>apply DAC(P1),DAC(P2),DAC(P3),....,DAC(PN)</p>
<p>combine(DAC(P1),DAC(P2),DAC(P3),....DAC(PN))</p>
<p>}</p>
<p>&nbsp;</p>
<p>MERGE SORT</p>
<p><img class="mw-mmv-final-image svg" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Merge_sort_algorithm_diagram.svg/1024px-Merge_sort_algorithm_diagram.svg.png" alt="" width="702" height="676" crossorigin="anonymous" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>STARSSENS MULTIPLICATION OF MATRIX:</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Let&nbsp;<em>A</em>,&nbsp;<em>B</em>&nbsp;be two&nbsp;<a title="Square matrix" href="https://en.wikipedia.org/wiki/Square_matrix">square matrices</a>&nbsp;over a&nbsp;<a title="Ring (mathematics)" href="https://en.wikipedia.org/wiki/Ring_(mathematics)">ring</a>&nbsp;<em>R</em>. We want to calculate the matrix product&nbsp;<em>C</em>&nbsp;as</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} =\mathbf {A} \mathbf {B} \qquad \mathbf {A} ,\mathbf {B} ,\mathbf {C} \in R^{2^{n}\times 2^{n}}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/96e48054fc368d460367e1f541a131ea4baedb99" alt="\mathbf {C} =\mathbf {A} \mathbf {B} \qquad \mathbf {A} ,\mathbf {B} ,\mathbf {C} \in R^{2^{n}\times 2^{n}}" aria-hidden="true" /></span></dd>
</dl>
<p>If the matrices&nbsp;<em>A</em>,&nbsp;<em>B</em>&nbsp;are not of type 2<sup><em>n</em></sup>&nbsp;&times; 2<sup><em>n</em></sup>&nbsp;we fill the missing rows and columns with zeros.</p>
<p>We partition&nbsp;<em>A</em>,&nbsp;<em>B</em>&nbsp;and&nbsp;<em>C</em>&nbsp;into equally sized&nbsp;<a title="Block matrix" href="https://en.wikipedia.org/wiki/Block_matrix">block matrices</a></p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {A} ={\begin{bmatrix}\mathbf {A} _{1,1}&amp;\mathbf {A} _{1,2}\\\mathbf {A} _{2,1}&amp;\mathbf {A} _{2,2}\end{bmatrix}}{\mbox{ , }}\mathbf {B} ={\begin{bmatrix}\mathbf {B} _{1,1}&amp;\mathbf {B} _{1,2}\\\mathbf {B} _{2,1}&amp;\mathbf {B} _{2,2}\end{bmatrix}}{\mbox{ , }}\mathbf {C} ={\begin{bmatrix}\mathbf {C} _{1,1}&amp;\mathbf {C} _{1,2}\\\mathbf {C} _{2,1}&amp;\mathbf {C} _{2,2}\end{bmatrix}}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/41c6337190684aff7b69f124226d6e62d79ebca5" alt="\mathbf {A} ={\begin{bmatrix}\mathbf {A} _{1,1}&amp;\mathbf {A} _{1,2}\\\mathbf {A} _{2,1}&amp;\mathbf {A} _{2,2}\end{bmatrix}}{\mbox{ , }}\mathbf {B} ={\begin{bmatrix}\mathbf {B} _{1,1}&amp;\mathbf {B} _{1,2}\\\mathbf {B} _{2,1}&amp;\mathbf {B} _{2,2}\end{bmatrix}}{\mbox{ , }}\mathbf {C} ={\begin{bmatrix}\mathbf {C} _{1,1}&amp;\mathbf {C} _{1,2}\\\mathbf {C} _{2,1}&amp;\mathbf {C} _{2,2}\end{bmatrix}}" aria-hidden="true" /></span></dd>
</dl>
<p>with</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {A} _{i,j},\mathbf {B} _{i,j},\mathbf {C} _{i,j}\in R^{2^{n-1}\times 2^{n-1}}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/480fbf677c5973cedb5218c69501a41e1b325a1a" alt="\mathbf {A} _{i,j},\mathbf {B} _{i,j},\mathbf {C} _{i,j}\in R^{2^{n-1}\times 2^{n-1}}" aria-hidden="true" /></span>.</dd>
</dl>
<p>The naive algorithm would be:</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{1,1}=\mathbf {A} _{1,1}\mathbf {B} _{1,1}+\mathbf {A} _{1,2}\mathbf {B} _{2,1}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d91fa79d27697a5c6551698c1a83a3d5837c57b" alt="\mathbf {C} _{1,1}=\mathbf {A} _{1,1}\mathbf {B} _{1,1}+\mathbf {A} _{1,2}\mathbf {B} _{2,1}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{1,2}=\mathbf {A} _{1,1}\mathbf {B} _{1,2}+\mathbf {A} _{1,2}\mathbf {B} _{2,2}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a08bea24eec9422cda82e6e04af1d96fc6822038" alt="\mathbf {C} _{1,2}=\mathbf {A} _{1,1}\mathbf {B} _{1,2}+\mathbf {A} _{1,2}\mathbf {B} _{2,2}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{2,1}=\mathbf {A} _{2,1}\mathbf {B} _{1,1}+\mathbf {A} _{2,2}\mathbf {B} _{2,1}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7adffe97db091ce8ba231352b3721bbe261985ca" alt="\mathbf {C} _{2,1}=\mathbf {A} _{2,1}\mathbf {B} _{1,1}+\mathbf {A} _{2,2}\mathbf {B} _{2,1}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{2,2}=\mathbf {A} _{2,1}\mathbf {B} _{1,2}+\mathbf {A} _{2,2}\mathbf {B} _{2,2}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8b40ed74cf54465d8e54d09b8492e50689928313" alt="\mathbf {C} _{2,2}=\mathbf {A} _{2,1}\mathbf {B} _{1,2}+\mathbf {A} _{2,2}\mathbf {B} _{2,2}" aria-hidden="true" /></span></dd>
</dl>
<p>With this construction we have not reduced the number of multiplications. We still need 8 multiplications to calculate the&nbsp;<em>C<sub>i,j</sub></em>&nbsp;matrices, the same number of multiplications we need when using standard matrix multiplication.</p>
<p>The Strassen algorithm defines instead new matrices:</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{1}:=(\mathbf {A} _{1,1}+\mathbf {A} _{2,2})(\mathbf {B} _{1,1}+\mathbf {B} _{2,2})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1e9e6268d824de7ad5010a32a1921452b264f7ee" alt="\mathbf {M} _{1}:=(\mathbf {A} _{1,1}+\mathbf {A} _{2,2})(\mathbf {B} _{1,1}+\mathbf {B} _{2,2})" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{2}:=(\mathbf {A} _{2,1}+\mathbf {A} _{2,2})\mathbf {B} _{1,1}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0d40beeba8019e378fa0ed4b6e549c44a140a9ec" alt="\mathbf {M} _{2}:=(\mathbf {A} _{2,1}+\mathbf {A} _{2,2})\mathbf {B} _{1,1}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{3}:=\mathbf {A} _{1,1}(\mathbf {B} _{1,2}-\mathbf {B} _{2,2})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45e8e9679d33f2c66e24bd812e1e554f95bb1571" alt="\mathbf {M} _{3}:=\mathbf {A} _{1,1}(\mathbf {B} _{1,2}-\mathbf {B} _{2,2})" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{4}:=\mathbf {A} _{2,2}(\mathbf {B} _{2,1}-\mathbf {B} _{1,1})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c12df2bb70f8f09f33f1ca4b8c2d577d5850a2ee" alt="\mathbf {M} _{4}:=\mathbf {A} _{2,2}(\mathbf {B} _{2,1}-\mathbf {B} _{1,1})" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{5}:=(\mathbf {A} _{1,1}+\mathbf {A} _{1,2})\mathbf {B} _{2,2}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/715adfa757b74b3ad6b4eea545c24762e4079161" alt="\mathbf {M} _{5}:=(\mathbf {A} _{1,1}+\mathbf {A} _{1,2})\mathbf {B} _{2,2}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{6}:=(\mathbf {A} _{2,1}-\mathbf {A} _{1,1})(\mathbf {B} _{1,1}+\mathbf {B} _{1,2})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/30107b9c9c99494bf75f23e84b505e5921cee46e" alt="\mathbf {M} _{6}:=(\mathbf {A} _{2,1}-\mathbf {A} _{1,1})(\mathbf {B} _{1,1}+\mathbf {B} _{1,2})" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {M} _{7}:=(\mathbf {A} _{1,2}-\mathbf {A} _{2,2})(\mathbf {B} _{2,1}+\mathbf {B} _{2,2})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9e93ef1c265be8be96209dde36230d56e139fc72" alt="\mathbf {M} _{7}:=(\mathbf {A} _{1,2}-\mathbf {A} _{2,2})(\mathbf {B} _{2,1}+\mathbf {B} _{2,2})" aria-hidden="true" /></span></dd>
</dl>
<p>only using 7 multiplications (one for each&nbsp;<em>M</em><sub>k</sub>) instead of 8. We may now express the&nbsp;<em>C</em><sub>i,j</sub>&nbsp;in terms of&nbsp;<em>M</em><sub>k</sub>:</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{1,1}=\mathbf {M} _{1}+\mathbf {M} _{4}-\mathbf {M} _{5}+\mathbf {M} _{7}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/26875b8ca1815e2c322c798faeecabe1d7836798" alt="\mathbf {C} _{1,1}=\mathbf {M} _{1}+\mathbf {M} _{4}-\mathbf {M} _{5}+\mathbf {M} _{7}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{1,2}=\mathbf {M} _{3}+\mathbf {M} _{5}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e71779a8ecc64f3e1268485cf389a05cdd3e6bf8" alt="\mathbf {C} _{1,2}=\mathbf {M} _{3}+\mathbf {M} _{5}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{2,1}=\mathbf {M} _{2}+\mathbf {M} _{4}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5853fa11f016df7eee4eb2a7ceb6137d3b3296de" alt="\mathbf {C} _{2,1}=\mathbf {M} _{2}+\mathbf {M} _{4}" aria-hidden="true" /></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle \mathbf {C} _{2,2}=\mathbf {M} _{1}-\mathbf {M} _{2}+\mathbf {M} _{3}+\mathbf {M} _{6}}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b7d7d4ee9e67e0c23f1a522787d4829072542dbb" alt="\mathbf {C} _{2,2}=\mathbf {M} _{1}-\mathbf {M} _{2}+\mathbf {M} _{3}+\mathbf {M} _{6}" aria-hidden="true" /></span></dd>
</dl>
<p>We iterate this division process&nbsp;<em>n</em>&nbsp;times (recursively) until the&nbsp;<a class="mw-redirect" title="Submatrices" href="https://en.wikipedia.org/wiki/Submatrices">submatrices</a>&nbsp;degenerate into numbers (elements of the ring&nbsp;<em>R</em>). The resulting product will be padded with zeroes just like&nbsp;<em>A</em>&nbsp;and&nbsp;<em>B</em>, and should be stripped of the corresponding rows and columns.</p>
<p>Practical implementations of Strassen's algorithm switch to standard methods of matrix multiplication for small enough submatrices, for which those algorithms are more efficient. The particular crossover point for which Strassen's algorithm is more efficient depends on the specific implementation and hardware. Earlier authors had estimated that Strassen's algorithm is faster for matrices with widths from 32 to 128 for optimized implementations.<sup id="cite_ref-1" class="reference"><a href="https://en.wikipedia.org/wiki/Strassen_algorithm#cite_note-1">[1]</a></sup>&nbsp;However, it has been observed that this crossover point has been increasing in recent years, and a 2010 study found that even a single step of Strassen's algorithm is often not beneficial on current architectures, compared to a highly optimized traditional multiplication, until matrix sizes exceed 1000 or more, and even for matrix sizes of several thousand the benefit is typically marginal at best (around 10% or less).<sup id="cite_ref-dalberto_2-0" class="reference"><a href="https://en.wikipedia.org/wiki/Strassen_algorithm#cite_note-dalberto-2">[2]</a></sup>&nbsp;A more recent study (2016) observed benefits for matrices as small as 512 and a benefit around 20%.<sup id="cite_ref-huang_et_al._3-0" class="reference"><a href="https://en.wikipedia.org/wiki/Strassen_algorithm#cite_note-huang_et_al.-3">[3]</a></sup></p>
<h2><span id="Asymptotic_complexity" class="mw-headline">Asymptotic complexity</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a title="Edit section: Asymptotic complexity" href="https://en.wikipedia.org/w/index.php?title=Strassen_algorithm&amp;action=edit&amp;section=3">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The standard matrix multiplication takes approximately&nbsp;<span class="texhtml">2<em>N</em><sup>3</sup></span>&nbsp;(where&nbsp;<span class="texhtml"><em>N</em>&nbsp;= 2<sup><em>n</em></sup>)</span>&nbsp;arithmetic operations (additions and multiplications); the asymptotic complexity is&nbsp;<span class="texhtml">&Theta;(<em>N</em><sup>3</sup>)</span>.</p>
<p>The number of additions and multiplications required in the Strassen algorithm can be calculated as follows: let&nbsp;<span class="texhtml"><em>f</em>(<em>n</em>)</span>&nbsp;be the number of operations for a&nbsp;<span class="texhtml">2<sup><em>n</em></sup>&nbsp;&times; 2<sup><em>n</em></sup></span>&nbsp;matrix. Then by recursive application of the Strassen algorithm, we see that&nbsp;<span class="texhtml"><em>f</em>(<em>n</em>) = 7<em>f</em>(<em>n</em>&minus;1) +&nbsp;<em>â„“</em>4<sup><em>n</em></sup></span>, for some constant&nbsp;<span class="texhtml mvar">â„“</span>&nbsp;that depends on the number of additions performed at each application of the algorithm. Hence&nbsp;<span class="texhtml"><em>f</em>(<em>n</em>) = (7 + o(1))<sup><em>n</em></sup></span>, i.e., the asymptotic complexity for multiplying matrices of size&nbsp;<span class="texhtml"><em>N</em>&nbsp;= 2<sup><em>n</em></sup></span>&nbsp;using the Strassen algorithm is</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle O([7+o(1)]^{n})=O(N^{\log _{2}7+o(1)})\approx O(N^{2.8074})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/511e64be8e75258905f4b3c61d73de72080e643c" alt="O([7+o(1)]^{n})=O(N^{\log _{2}7+o(1)})\approx O(N^{2.8074})" aria-hidden="true" /></span>.</dd>
</dl>
<p>The reduction in the number of arithmetic operations however comes at the price of a somewhat reduced&nbsp;<a title="Numerical stability" href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a>,<sup id="cite_ref-4" class="reference"><a href="https://en.wikipedia.org/wiki/Strassen_algorithm#cite_note-4">[4]</a></sup>&nbsp;and the algorithm also requires significantly more memory compared to the naive algorithm. Both initial matrices must have their dimensions expanded to the next power of 2, which results in storing up to four times as many elements, and the seven auxiliary matrices each contain a quarter of the elements in the expanded ones.</p>
<p>The "naive" way of doing the matrix multiplication would require 8 instead of 7 multiplications of sub-blocks. This would then give rise to the complexity one expects from the standard approach:</p>
<dl>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y">{\displaystyle O(8^{log_{2}n})=O(N^{\log _{2}8})=O(N^{3})}</span><img class="mwe-math-fallback-image-inline" src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d2fca7dbeb1703e1d484e07dec8b9026289cd112" alt="{\displaystyle O(8^{log_{2}n})=O(N^{\log _{2}8})=O(N^{3})}" aria-hidden="true" /></span>.</dd>
</dl>
